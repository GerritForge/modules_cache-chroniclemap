{
  "comments": [
    {
      "key": {
        "uuid": "32b04cab_d9db4da3",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-09-22T21:29:39Z",
      "side": 1,
      "message": "Why do we need this extra in-memory value? The timestamp could be just an implementation detail of the ChronicleMap serialisation. If we read a value that has expired, we just do not return anything and we remove it from the store, without the need to return it in memory as a TimedValue.\n\nWDYT?",
      "revId": "1b9c3c02f5a1ca406dfced06bf2f27b602f22838",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c35cabe9_70d522ee",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1015244
      },
      "writtenOn": "2020-09-24T13:25:30Z",
      "side": 1,
      "message": "Ok, Apologies if I completely misunderstood your suggestion ðŸ˜Š\n\nIf get what you are saying, you are proposing to get the _deserializer_ to decide whether the object is stale and in that case return null rather than the object?\nThen have some logic whereby if a null object is returned from the store, the key is also removed.\n\nI think the deserializer should do just that, deserialize an array of bytes, rather applying eviction logic to the stored objects.\nIsn\u0027t that responsibility of the cacheImpl, which will take the decision based on the configuration?\n\nAlso, readBytes always receives a serialized input, I don\u0027t think it is _ever_ expected to return null, but always a T.\n\nDid I get you wrong?\n\n[1]https://www.javadoc.io/doc/net.openhft/chronicle-map/3.8.0/net/openhft/chronicle/hash/serialization/BytesReader.html",
      "parentUuid": "32b04cab_d9db4da3",
      "revId": "1b9c3c02f5a1ca406dfced06bf2f27b602f22838",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31cf6b51_d2c09eeb",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-09-25T11:08:22Z",
      "side": 1,
      "message": "I am concerned from a performance standpoint, which is exactly the reason why we are using ChronicleMap: it should be super-lighting fast.\n\nThis new object is created and destroyed continuously, serialised and deserialised but never returned upstream because it is an internal implementation.\n\nWe do know that a stale value should never be returned, right? So why returning a new TimedValue knowing that is stale and knowing that the caller would just put into the GC? We are just wasting CPU cycles and giving lots of extra work for the Java GC.\n\nWhat do you think?",
      "parentUuid": "c35cabe9_70d522ee",
      "revId": "1b9c3c02f5a1ca406dfced06bf2f27b602f22838",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "738e0c15_cc390c80",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1015244
      },
      "writtenOn": "2020-09-28T09:37:01Z",
      "side": 1,
      "message": "I understand your point, however:\n\n- What you are suggesting would require to move the invalidation logic directly into the marshaller. I find this wrong from a responsibility point of view, but not only: the BytesReader.read() method used for deserialization is explicitly flagged as returning @NotNull results[1]. We would need to break that contract.\n\n- As a mitigation of this, an additional change could be: If maxAge is not configured, we could skip the entire wrapping into TimedValue.\n\n- It sounds to me a pre-optimization to be honest. it\u0027d be useful to measure how much overhead is added by deserializing and keeping in memory the TimedValue\u003cV\u003e rather than V. Cached values (with some exceptions) are already complex types that occupy hundreds of bytes\n   * Perhaps the addition/(de)serialization of 12 bytes does not make a noticeable difference.\n   * The value, if expired, will be invalidated immediately after by the cache implementation so it will not occupy any space in memory.\n\nShould we measure what\u0027s the impact of this wrapping over performance (perhaps with a load test) and act accordingly?\n\n[1]https://github.com/OpenHFT/Chronicle-Map/blob/master/src/main/java/net/openhft/chronicle/hash/serialization/BytesReader.java#L58",
      "parentUuid": "31cf6b51_d2c09eeb",
      "revId": "1b9c3c02f5a1ca406dfced06bf2f27b602f22838",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3649d05_9de86ad3",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2020-09-28T15:36:39Z",
      "side": 1,
      "message": "\u003e I understand your point, however:\n\u003e \n\u003e - What you are suggesting would require to move the invalidation logic directly into the marshaller. I find this wrong from a responsibility point of view, but not only: the BytesReader.read() method used for deserialization is explicitly flagged as returning @NotNull results[1]. We would need to break that contract.\n\nTrue. That was just an idea, but my point was trying to avoid creating in-memory objects that were immediately thrown away.\n\n\u003e - As a mitigation of this, an additional change could be: If maxAge is not configured, we could skip the entire wrapping into TimedValue.\n\u003e \n\u003e - It sounds to me a pre-optimization to be honest. it\u0027d be useful to measure how much overhead is added by deserializing and keeping in memory the TimedValue\u003cV\u003e rather than V. Cached values (with some exceptions) are already complex types that occupy hundreds of bytes\n\u003e    * Perhaps the addition/(de)serialization of 12 bytes does not make a noticeable difference.\n\u003e    * The value, if expired, will be invalidated immediately after by the cache implementation so it will not occupy any space in memory.\n\u003e \n\u003e Should we measure what\u0027s the impact of this wrapping over performance (perhaps with a load test) and act accordingly?\n\u003e \n\u003e [1]https://github.com/OpenHFT/Chronicle-Map/blob/master/src/main/java/net/openhft/chronicle/hash/serialization/BytesReader.java#L58\n\nYes, we should manage this as a follow-up, measuring the JVM GC impact of it. For now, marking this as resolved.",
      "parentUuid": "738e0c15_cc390c80",
      "revId": "1b9c3c02f5a1ca406dfced06bf2f27b602f22838",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}